:global
:noTypeCheck

class Numb(n: Int)

:e
fun process(e) =
  if e is
    Numb(n) and n > 0 then n
    Numb(m) then n
//│ ╔══[ERROR] Name not found: n
//│ ║  l.10: 	    Numb(m) then n
//│ ╙──      	                 ^


process(Numb(-10))

fun process(e, n) =
  if e is
    Numb(n) and n > 0 then n
    Numb(m) then n + m

process(Numb(0), 10)
process(Numb(-1), 10)
process(Numb(1), 10)


// class Vec(xs: Array[Numb | Vec]) // Array is not available
abstract class Vec[out T]
class Cons[out T](head: T, tail: Vec[T]) extends Vec[T]
module Nil extends Vec[nothing]
//│ FAILURE: Unexpected type error
//│ ╔══[ERROR] Expected a valid definition head, found infix application instead
//│ ║  l.30: 	class Cons[out T](head: T, tail: Vec[T]) extends Vec[T]
//│ ╙──      	      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ FAILURE: Unexpected type error
//│ ╔══[ERROR] Expected a valid definition head, found infix application instead
//│ ║  l.31: 	module Nil extends Vec[nothing]
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^^^^
//│ FAILURE: Unexpected exception
//│ /!!!\ Uncaught error: scala.MatchError: InfixApp(App(App(Ident(Cons),TyTup(List(Modified(keyword 'out',Ident(T))))),Tup(List(InfixApp(Ident(head),keyword ':',Ident(T)), InfixApp(Ident(tail),keyword ':',App(Ident(Vec),TyTup(List(Ident(T)))))))),keyword 'extends',App(Ident(Vec),TyTup(List(Ident(T))))) (of class hkmc2.syntax.Tree$InfixApp)
//│ 	at: hkmc2.semantics.Elaborator.processHead$1(Elaborator.scala:360)
//│ 	at: hkmc2.semantics.Elaborator.go$1(Elaborator.scala:362)
//│ 	at: hkmc2.semantics.Elaborator.block$$anonfun$3(Elaborator.scala:387)
//│ 	at: hkmc2.utils.TraceLogger.trace(TraceLogger.scala:17)
//│ 	at: hkmc2.semantics.Elaborator.block(Elaborator.scala:387)
//│ 	at: hkmc2.semantics.Elaborator.topLevel(Elaborator.scala:441)
//│ 	at: hkmc2.MLsDiffMaker.processTrees(MLsDiffMaker.scala:121)
//│ 	at: hkmc2.MLsDiffMaker.processOrigin(MLsDiffMaker.scala:105)
//│ 	at: hkmc2.DiffMaker.processBlock(DiffMaker.scala:155)
//│ 	at: hkmc2.DiffMaker.rec(DiffMaker.scala:249)

class Pair[A, B](a: A, b: B)

:e
fun process(e) =
  if e is
    Pair(Numb(n), Numb(m)) then Numb(n + m)
    Pair(Vec(xs), Vec(ys)) then n
    Pair(Vec(n),  Numb(n)) then n
    Pair(Numb(n), Vec(n))  then n
//│ ╔══[ERROR] Unknown constructor `Vec`.
//│ ║  l.61: 	    Pair(Numb(n), Vec(n))  then n
//│ ╙──      	                  ^^^
//│ ╔══[ERROR] Unknown constructor `Vec`.
//│ ║  l.60: 	    Pair(Vec(n),  Numb(n)) then n
//│ ╙──      	         ^^^
//│ ╔══[ERROR] Unknown constructor `Vec`.
//│ ║  l.59: 	    Pair(Vec(xs), Vec(ys)) then n
//│ ╙──      	         ^^^


// * FIXME should warn, be rejected, or compare both values for equality
fun process(e) =
  if e is
    Pair(Numb(n), Numb(n)) then n

process(Pair(Numb(1), Numb(2)))


