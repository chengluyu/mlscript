:bbml



fun letreg: [E,Res] -> ([R] -> Region[R] ->{E | R} Res) ->{E} Res
//│ Type: ⊤

letreg
//│ Type: forall α0_2, α1_2: (forall α2_3: (Region[α2_3]) ->{α0_2 ∨ α2_3} α1_2) ->{α0_2} α1_2

letreg(r => r)
//│ Type: Region[?]

:e
letreg(r => r).ref 1
//│ ╔══[ERROR] Type error in reference creation
//│ ║  l.15: 	letreg(r => r).ref 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α7_1  <:  Region[α9_1]
//│ ╟── because: cannot constrain  α7_1  <:  ¬(~{Region[α9_1]})
//│ ╟── because: cannot constrain  Region[out ¬⊥] ∧ ¬⊥  <:  ¬(~{Region[α9_1]})
//│ ╟── because: cannot constrain  D(  )  <:  α9_1
//│ ╟── because: cannot constrain    <:  α9_1
//│ ╙── because: cannot constrain    <:  ¬()
//│ ╔══[ERROR] Type error in block
//│ ║  l.15: 	letreg(r => r).ref 1
//│ ║        	^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α9_1 ∨ α6_1  <:  Alloc
//│ ╟── because: cannot constrain  α9_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain    <:  ¬(~{Alloc})
//│ Type: Ref[Int, ?]

letreg(r => r.ref 1)
//│ Type: Ref[Int, ?]

letreg(r => !(r.ref 1))
//│ Type: Int

:e
!letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in block
//│ ║  l.40: 	!letreg(r => r.ref 1)
//│ ║        	 ^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α26_1 ∨ α21_1  <:  Alloc
//│ ╟── because: cannot constrain  α26_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α25_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α25_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: Int

letreg of r =>
  let x = r.ref 1
  x := !x + 1
  !x
//│ Type: Int

let f = letreg(r => arg => r.ref arg)
//│ Type: ⊤

:e
f
//│ ╔══[ERROR] Variable not found: f
//│ ║  l.61: 	f
//│ ╙──      	^
//│ Type: ⊥

:e
letreg(r => arg => r.ref arg)(0)
//│ ╔══[ERROR] Type error in block
//│ ║  l.68: 	letreg(r => arg => r.ref arg)(0)
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α53_1 ∨ α45_1  <:  Alloc
//│ ╟── because: cannot constrain  α53_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α52_1  <:  ¬(~{Alloc})
//│ ╟── because: cannot constrain  α52_1  <:  ¬(~{Alloc})
//│ ╙── because: cannot constrain  ¬⊥  <:  ¬(~{Alloc})
//│ Type: Ref[α50_1, ?]
//│ Where:
//│   Int <: α50_1



// * An incorrect one, just for testing the error:

fun letreg: [E,Res] -> ([R] -> Region[R] -> Res) ->{E} Res
//│ Type: ⊤

:e
letreg(r => r.ref 1)
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<α>60_2]) ->{⊥} α59_1
//│ ║  l.89: 	letreg(r => r.ref 1)
//│ ║        	       ^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α61_2  <:  ⊥
//│ ╟── because: cannot constrain  α61_2  <:  ¬()
//│ ╙── because: cannot constrain  <α>60_2  <:  ¬()
//│ Type: Ref[Int, ?]

:e
letreg(r => !(r.ref 1))
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<α>65_2]) ->{⊥} α64_1
//│ ║  l.99: 	letreg(r => !(r.ref 1))
//│ ║        	       ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α67_2 ∨ α66_2  <:  ⊥
//│ ╟── because: cannot constrain  α67_2  <:  ¬()
//│ ╟── because: cannot constrain  α66_2  <:  ¬()
//│ ╟── because: cannot constrain  α66_2  <:  ¬()
//│ ╙── because: cannot constrain  <α>65_2  <:  ¬()
//│ ╔══[ERROR] Type error in function literal with expected type (Region[<α>65_2]) ->{⊥} α64_1
//│ ║  l.99: 	letreg(r => !(r.ref 1))
//│ ║        	       ^^^^^^^^^^^^^^
//│ ╟── because: cannot constrain  α67_2 ∨ α66_2  <:  ⊥
//│ ╟── because: cannot constrain  α66_2  <:  ¬()
//│ ╙── because: cannot constrain  <α>65_2  <:  ¬()
//│ Type: Int


