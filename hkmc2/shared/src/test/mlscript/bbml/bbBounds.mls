:bbml


(x => x + 1): [A extends Int] -> A -> Int
//│ Type: (Int) ->{⊥} Int


(x => x): [A restricts Int] -> A -> A
//│ Type: forall α2_2: (α2_2) ->{⊥} α2_2
//│ Where:
//│   Int <: α2_2


(x => x - 1): [A extends Int restricts Int] -> A -> A
//│ Type: forall α4_2: (α4_2) ->{⊥} α4_2
//│ Where:
//│   Int <: α4_2
//│   α4_2 <: Int

fun iid: [A extends Int] -> A -> A
fun iid(x) = x
//│ Type: ⊤

iid
//│ Type: forall α7_2: (α7_2) ->{⊥} α7_2
//│ Where:
//│   α7_2 <: Int

:e
iid("42")
//│ ╔══[ERROR] Type error in string literal with expected type α9_1
//│ ║  l.30: 	iid("42")
//│ ║        	    ^^^^
//│ ╟── because: cannot constrain  Str  <:  α9_1
//│ ╟── because: cannot constrain  Str  <:  α9_1
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: Str


iid(42)
//│ Type: Int

class Foo[A]
//│ Type: ⊤

fun foo: [A extends Foo[in Nothing out Any] restricts Foo[in Num]] -> A -> A
foo
//│ Type: forall α11_2: (α11_2) ->{⊥} α11_2
//│ Where:
//│   Foo[in Num] <: α11_2
//│   α11_2 <: Foo[?]

fun bar: Foo[in Num out Int]
//│ Type: ⊤

foo(bar)
//│ Type: Foo[in Num out Int] ∨ Foo[in Num]

:e
fun badfoo: [A extends Str restricts Int] -> A -> A
//│ ╔══[ERROR] Type error in block
//│ ║  l.60: 	fun badfoo: [A extends Str restricts Int] -> A -> A
//│ ║        	                                             ^^^^^^
//│ ╙── because: cannot constrain  Int  <:  Str
//│ Type: ⊤


fun baz: [A extends B, B extends A] -> A -> B
baz
//│ Type: (⊤) ->{⊥} ⊤

fun bazbaz: [A extends Int] -> A -> [B extends A] -> B
bazbaz
//│ Type: (Int) ->{⊥} forall α17_3: ⊥

fun foofun: [A extends Int -> Int restricts Any -> Int] -> A -> Int -> Int
foofun
//│ Type: (Int -> Int) ->{⊥} (Int) ->{⊥} Int

foofun(x => x + 1)(42)
//│ Type: Int

fun bazbaz: [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
bazbaz
//│ Type: forall α21_2: (α21_2) ->{⊥} (forall α22_3: α21_2 -> α21_2) ->{⊥} α21_2
//│ Where:
//│   α21_2 <: Int

bazbaz(42)(x => x + 1)
//│ Type: Int

fun cc: [A extends B -> B restricts B -> B, B extends A -> A restricts A -> A] -> A -> B -> Bool
cc
//│ Type: forall α26_2, α27_2: (α26_2) ->{⊥} (α27_2) ->{⊥} Bool
//│ Where:
//│   α26_2 -> α26_2 <: α27_2
//│   α27_2 <: α26_2 -> α26_2
//│   α27_2 -> α27_2 <: α26_2
//│   α26_2 <: α27_2 -> α27_2

fun w: Any -> Nothing
//│ Type: ⊤

cc(w)(w)
//│ Type: Bool

fun h: [C] -> ([A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A) -> C -> Int
//│ Type: ⊤

:e
bazbaz: [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
//│ ╔══[ERROR] Cannot type non-function term Ref(bazbaz) as (<α>35_2) ->{⊥} (forall α34_3: α34_3) ->{⊥} <α>35_2
//│ ║  l.111: 	bazbaz: [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
//│ ╙──       	^^^^^^
//│ Type: forall α33_2: (α33_2) ->{⊥} (forall α34_3: α33_2 -> α33_2) ->{⊥} α33_2
//│ Where:
//│   α33_2 <: Int


(x => f => bazbaz(x)(f)): [A extends Int] -> A -> ([B extends A -> A restricts A -> A] -> B) -> A
//│ Type: forall α36_2: (α36_2) ->{⊥} (forall α37_3: α36_2 -> α36_2) ->{⊥} α36_2
//│ Where:
//│   α36_2 <: Int


h(x => f => bazbaz(x)(f))(42)
//│ Type: Int

