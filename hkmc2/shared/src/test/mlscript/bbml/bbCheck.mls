:global
:bbml


fun add: (Int, Int) -> Int
fun add(x, y) = x + y
//│ Type: ⊤

// FIXME locations
:e
fun foo: Int -> Int
fun foo: Int -> Int
//│ ╔══[ERROR] Duplicate definition of foo
//│ ║  l.12: 	fun foo: Int -> Int
//│ ║        	    ^^^^^^^^^^^^^^^
//│ ╟── aready defined here
//│ ║  l.12: 	fun foo: Int -> Int
//│ ╙──      	    ^^^
//│ Type: ⊤

:e
fun id(x) = x
fun id(y) = y
//│ ╔══[ERROR] Duplicate definition of id
//│ ║  l.23: 	fun id(y) = y
//│ ║        	    ^^^^^^^^^
//│ ╟── aready defined here
//│ ║  l.23: 	fun id(y) = y
//│ ╙──      	    ^^
//│ Type: ⊤

:e
fun bar: Str -> Str
fun bar(x) = let t = x + 1 in "aaa"
//│ ╔══[ERROR] Type error in reference with expected type Int
//│ ║  l.34: 	fun bar(x) = let t = x + 1 in "aaa"
//│ ║        	                     ^
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: ⊤

:e
fun baz: Int -> Int
fun baz(x) = "bbb"
//│ ╔══[ERROR] Type error in string literal with expected type Int
//│ ║  l.43: 	fun baz(x) = "bbb"
//│ ║        	             ^^^^^
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: ⊤

add(1, 2)
//│ Type: Int

add(1, 2): Int
//│ Type: Int


:e
add(0, 0): Str
//│ ╔══[ERROR] Type error in application with expected type Str
//│ ║  l.58: 	add(0, 0): Str
//│ ║        	^^^^^^^^^
//│ ╙── because: cannot constrain  Int  <:  Str
//│ Type: Str

:e
fun errAdd(x: Int) = x + "1"
//│ ╔══[ERROR] Type error in string literal with expected type Int
//│ ║  l.66: 	fun errAdd(x: Int) = x + "1"
//│ ║        	                         ^^^
//│ ╙── because: cannot constrain  Str  <:  Int
//│ Type: ⊤

fun high: ([A] -> A -> A) -> Int
fun high(f) = f(42)
//│ Type: ⊤

high
//│ Type: (forall α6_2: (α6_2) ->{⊥} α6_2) ->{⊥} Int


high((x => x): [A] -> A -> A)
//│ Type: Int

high(x => x)
//│ Type: Int

:e
high(x => x + 1)
//│ ╔══[ERROR] Type error in reference with expected type Int
//│ ║  l.88: 	high(x => x + 1)
//│ ║        	          ^
//│ ╙── because: cannot constrain  <α>6_2  <:  Int
//│ ╔══[ERROR] Type error in application with expected type <α>6_2
//│ ║  l.88: 	high(x => x + 1)
//│ ║        	          ^^^^^
//│ ╙── because: cannot constrain  Int  <:  <α>6_2
//│ Type: Int

(let a = 0 in x => x): [A] -> A -> A
//│ Type: forall α8_2: (α8_2) ->{⊥} α8_2

(if false then x => x else y => y): [A] -> A -> A
//│ FAILURE: Unexpected exception
//│ /!!!\ Uncaught error: scala.MatchError: Cons(Branch(Ref(scrut@90),LitPat(BoolLit(true)),Else(Lam(List(Param(‹›,x@91,None)),Ref(x@91)))),Else(Lam(List(Param(‹›,y@89,None)),Ref(y@89)))) (of class hkmc2.semantics.Split$Cons)
//│ 	at: hkmc2.bbml.BBTyper.typeSplit(bbML.scala:368)
//│ 	at: hkmc2.bbml.BBTyper.typeSplit(bbML.scala:363)
//│ 	at: hkmc2.bbml.BBTyper.ascribe$$anonfun$3(bbML.scala:402)
//│ 	at: hkmc2.utils.TraceLogger.trace(TraceLogger.scala:17)
//│ 	at: hkmc2.bbml.BBTyper.ascribe(bbML.scala:413)
//│ 	at: hkmc2.bbml.BBTyper.ascribe$$anonfun$3(bbML.scala:392)
//│ 	at: hkmc2.utils.TraceLogger.trace(TraceLogger.scala:17)
//│ 	at: hkmc2.bbml.BBTyper.ascribe(bbML.scala:413)
//│ 	at: hkmc2.bbml.BBTyper.typeCheck$$anonfun$3(bbML.scala:563)
//│ 	at: hkmc2.utils.TraceLogger.trace(TraceLogger.scala:17)


fun baz: Int -> (([A] -> A -> A), Int) -> Int
fun baz(z) =
  ((f, x) => f(x))
//│ Type: ⊤

fun baz: Int -> (([A] -> A -> A), Int) -> Int
fun baz(z) =
  ((f, x) => f(x)): (([A] -> A -> A), Int) -> Int
//│ Type: ⊤

:e
baz: Int -> (([A] -> A -> A), Int) -> Int
//│ ╔══[ERROR] Cannot type non-function term Ref(baz) as (Int) ->{⊥} (forall α19_2: (α19_2) ->{⊥} α19_2, Int) ->{⊥} Int
//│ ║  l.128: 	baz: Int -> (([A] -> A -> A), Int) -> Int
//│ ╙──       	^^^
//│ Type: ⊥


baz(42)
//│ Type: (forall α15_2: (α15_2) ->{⊥} α15_2, Int) ->{⊥} Int

:e
baz(42): (([A] -> A -> A), Int) -> Int
//│ ╔══[ERROR] Cannot type non-function term App(Ref(baz),Tup(List(Fld(‹›,Lit(IntLit(42)),None)))) as (forall α20_2: (α20_2) ->{⊥} α20_2, Int) ->{⊥} Int
//│ ║  l.139: 	baz(42): (([A] -> A -> A), Int) -> Int
//│ ╙──       	^^^^^^^
//│ Type: ⊥

(z => (f, x) => baz(z)(f, x)): Int -> (([A] -> A -> A), Int) -> Int
//│ Type: (Int) ->{⊥} (forall α21_2: (α21_2) ->{⊥} α21_2, Int) ->{⊥} Int


fun id: [A] -> A -> A
fun id(x) = x
//│ Type: ⊤

id: [A] -> A -> A
//│ Type: forall α25_2: (α25_2) ->{⊥} α25_2


(id: [A] -> A -> A): [A] -> A -> A
//│ Type: forall α27_2: (α27_2) ->{⊥} α27_2

42: Int | Num
//│ Type: Int ∨ Num

42: [A] -> Int
//│ Type: Int


42: [A] -> Int | Num
//│ Type: Int ∨ Num

fun foo: Int -> Int
foo
//│ Type: (Int) ->{⊥} Int

foo
//│ Type: (Int) ->{⊥} Int
