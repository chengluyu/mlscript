:global
:p

keyword x
keyword y
keyword z
//│ |keyword| |x|↵|keyword| |y|↵|keyword| |z|
//│ Pretty-print: Nil
//│ AST: Nil
//│ Keywords: `::=` 2 2, `=>` 3 2, `define`, `keyword`, `syntax`, `x`, `y`, `z`, `~>` 2 2
//│ Rules: default ::= ‹Expr›

:pe
keyword x
x
//│ |keyword| |x|↵|x|
//│ ╔══[PARSE ERROR] Expected an expression; found `x` instead
//│ ║  l.15: 	x
//│ ╙──      	^
//│ Pretty-print: ?
//│ AST: Empty
//│ Keywords: `::=` 2 2, `=>` 3 2, `define`, `keyword`, `syntax`, `x`, `~>` 2 2
//│ Rules: default ::= ‹Expr›

keyword 10 inc
define Inc ::= inc Expr ~> ($1 + 1)
inc x
inc 1 + 2
//│ |keyword| |10| |inc|↵|define| |Inc| |::=| |inc| |Expr| |~>| |(|$1| |+| |1|)|↵|inc| |x|↵|inc| |1| |+| |2|
//│ Pretty-print:
//│   x + 1
//│   1 + 2 + 1
//│ AST:
//│   App(App(Var(+),Var(x)),Const(IntLit(1)))
//│   App(App(Var(+),App(App(Var(+),Const(IntLit(1))),Const(IntLit(2)))),Const(IntLit(1)))
//│ Keywords: `::=` 2 2, `=>` 3 2, `define`, `inc` 10, `keyword`, `syntax`, `~>` 2 2
//│ Rules: default ::= ‹Expr›, Inc ::= inc ‹Expr›

// Warn about wrong indices
:w
keyword 10 dec
define Dec ::= dec Expr ~> ($2 - 1)
dec x
//│ |keyword| |10| |dec|↵|define| |Dec| |::=| |dec| |Expr| |~>| |(|$2| |-| |1|)|↵|dec| |x|
//│ ╔══[WARNING] Invalid meta-variable index 2
//│ ║  l.42: 	define Dec ::= dec Expr ~> ($2 - 1)
//│ ╙──      	                            ^^
//│ Pretty-print: $2 - 1
//│ AST: App(App(Var(-),Var($2)),Const(IntLit(1)))
//│ Keywords: `::=` 2 2, `=>` 3 2, `dec` 10, `define`, `keyword`, `syntax`, `~>` 2 2
//│ Rules: default ::= ‹Expr›, Dec ::= dec ‹Expr›

keyword 0 let
keyword as
keyword in
define LetIn ::= let Expr as Expr in Expr ~> ($1 => $3)($2)
let x as 1 in x + 1
//│ |keyword| |0| |let|↵|keyword| |as|↵|keyword| |in|↵|define| |LetIn| |::=| |let| |Expr| |as| |Expr| |in| |Expr| |~>| |(|$1| |=>| |$3|)|(|$2|)|↵|let| |x| |as| |1| |in| |x| |+| |1|
//│ Pretty-print: (x => x)(1) + 1
//│ AST: App(App(Var(+),App(Lam(Var(x),Var(x)),Const(IntLit(1)))),Const(IntLit(1)))
//│ Keywords: `::=` 2 2, `=>` 3 2, `as`, `define`, `in`, `keyword`, `let` 0, `syntax`, `~>` 2 2
//│ Rules: default ::= ‹Expr›, LetIn ::= let ‹Expr› as ‹Expr› in ‹Expr›

keyword 0 let
keyword =
keyword in
define LetIn ::= let Expr = Expr in Expr ~> ($1 => $3)($2)
let x = 1 in x
//│ |keyword| |0| |let|↵|keyword| |=|↵|keyword| |in|↵|define| |LetIn| |::=| |let| |Expr| |=| |Expr| |in| |Expr| |~>| |(|$1| |=>| |$3|)|(|$2|)|↵|let| |x| |=| |1| |in| |x|
//│ Pretty-print: (x => x)(1)
//│ AST: App(Lam(Var(x),Var(x)),Const(IntLit(1)))
//│ Keywords: `::=` 2 2, `=`, `=>` 3 2, `define`, `in`, `keyword`, `let` 0, `syntax`, `~>` 2 2
//│ Rules: default ::= ‹Expr›, LetIn ::= let ‹Expr› = ‹Expr› in ‹Expr›
