:NewDefs
:ParseOnly

class A(x) {
  class B(y) {
    fun getX = x
    fun getB1 = B1(y)
    class C(z) {
      fun inc() = x + 1
      fun getY = y
      fun getA = A(z)
      fun getB(w) = B(w)
      fun getC = new C(inc())
      fun getSelf = this
    }
  }
  class B1(y) {
    fun getX = x
    fun getY = y
    fun getB = new B(y)
    fun getB1 = new B1(y)
  }
  fun getB = new B(x)
  fun getB2(y) = B1(y)
  fun getB3(z) = getB2(z)
  fun getA = A(x)
}
//│ |#class| |A|(|x|)| |{|→|#class| |B|(|y|)| |{|→|#fun| |getX| |#=| |x|↵|#fun| |getB1| |#=| |B1|(|y|)|↵|#class| |C|(|z|)| |{|→|#fun| |inc|(||)| |#=| |x| |+| |1|↵|#fun| |getY| |#=| |y|↵|#fun| |getA| |#=| |A|(|z|)|↵|#fun| |getB|(|w|)| |#=| |B|(|w|)|↵|#fun| |getC| |#=| |#new| |C|(|inc|(||)|)|↵|#fun| |getSelf| |#=| |this|←|↵|}|←|↵|}|↵|#class| |B1|(|y|)| |{|→|#fun| |getX| |#=| |x|↵|#fun| |getY| |#=| |y|↵|#fun| |getB| |#=| |#new| |B|(|y|)|↵|#fun| |getB1| |#=| |#new| |B1|(|y|)|←|↵|}|↵|#fun| |getB| |#=| |#new| |B|(|x|)|↵|#fun| |getB2|(|y|)| |#=| |B1|(|y|)|↵|#fun| |getB3|(|z|)| |#=| |getB2|(|z|)|↵|#fun| |getA| |#=| |A|(|x|)|←|↵|}|
//│ Parsed: {class A(x,) {class B(y,) {fun getX = x; fun getB1 = B1(y,); class C(z,) {fun inc = () => +(x, 1,); fun getY = y; fun getA = A(z,); fun getB = (w,) => B(w,); fun getC = (new C)(inc(),); fun getSelf = this}}; class B1(y,) {fun getX = x; fun getY = y; fun getB = (new B)(y,); fun getB1 = (new B1)(y,)}; fun getB = (new B)(x,); fun getB2 = (y,) => B1(y,); fun getB3 = (z,) => getB2(z,); fun getA = A(x,)}}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(x)))))),None,None,List(),None,None,TypingUnit(List(NuTypeDef(Cls,TypeName(B),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(y)))))),None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(getX),None,List(),Left(Var(x))), NuFunDef(None,Var(getB1),None,List(),Left(App(Var(B1),Tup(List((None,Fld(FldFlags(false,false,false),Var(y)))))))), NuTypeDef(Cls,TypeName(C),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(z)))))),None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(inc),None,List(),Left(Lam(Tup(List()),App(Var(+),Tup(List((None,Fld(FldFlags(false,false,false),Var(x))), (None,Fld(FldFlags(false,false,false),IntLit(1))))))))), NuFunDef(None,Var(getY),None,List(),Left(Var(y))), NuFunDef(None,Var(getA),None,List(),Left(App(Var(A),Tup(List((None,Fld(FldFlags(false,false,false),Var(z)))))))), NuFunDef(None,Var(getB),None,List(),Left(Lam(Tup(List((None,Fld(FldFlags(false,false,false),Var(w))))),App(Var(B),Tup(List((None,Fld(FldFlags(false,false,false),Var(w))))))))), NuFunDef(None,Var(getC),None,List(),Left(App(NuNew(Var(C)),Tup(List((None,Fld(FldFlags(false,false,false),App(Var(inc),Tup(List()))))))))), NuFunDef(None,Var(getSelf),None,List(),Left(Var(this))))))))), NuTypeDef(Cls,TypeName(B1),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(y)))))),None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(getX),None,List(),Left(Var(x))), NuFunDef(None,Var(getY),None,List(),Left(Var(y))), NuFunDef(None,Var(getB),None,List(),Left(App(NuNew(Var(B)),Tup(List((None,Fld(FldFlags(false,false,false),Var(y)))))))), NuFunDef(None,Var(getB1),None,List(),Left(App(NuNew(Var(B1)),Tup(List((None,Fld(FldFlags(false,false,false),Var(y))))))))))), NuFunDef(None,Var(getB),None,List(),Left(App(NuNew(Var(B)),Tup(List((None,Fld(FldFlags(false,false,false),Var(x)))))))), NuFunDef(None,Var(getB2),None,List(),Left(Lam(Tup(List((None,Fld(FldFlags(false,false,false),Var(y))))),App(Var(B1),Tup(List((None,Fld(FldFlags(false,false,false),Var(y))))))))), NuFunDef(None,Var(getB3),None,List(),Left(Lam(Tup(List((None,Fld(FldFlags(false,false,false),Var(z))))),App(Var(getB2),Tup(List((None,Fld(FldFlags(false,false,false),Var(z))))))))), NuFunDef(None,Var(getA),None,List(),Left(App(Var(A),Tup(List((None,Fld(FldFlags(false,false,false),Var(x)))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1_B$2_C$4([par$A$1_B$2, z, x,]) {
//│     fun inc = () => +((this).x, 1,)
//│     fun getY = () => ((this).par$A$1_B$2).y
//│     fun getA = () => A$1((this).z,)
//│     fun getB = (w,) => A$1_B$2(((this).par$A$1_B$2).par$A$1, w,)
//│     fun getC = () => new A$1_B$2_C$4([(this).par$A$1_B$2, (this).inc(), (this).x,]) {}
//│     fun getSelf = () => this
//│   }
//│   class A$1_B$2([par$A$1, y,]) {
//│     fun getX = () => ((this).par$A$1).x
//│     fun getB1 = () => A$1_B1$3((this).par$A$1, (this).y,)
//│   }
//│   class A$1_B1$3([par$A$1, y,]) {
//│     fun getX = () => ((this).par$A$1).x
//│     fun getY = () => (this).y
//│     fun getB = () => new A$1_B$2([(this).par$A$1, (this).y,]) {}
//│     fun getB1 = () => new A$1_B1$3([(this).par$A$1, (this).y,]) {}
//│   }
//│   class A$1([x,]) {
//│     fun getB = () => new A$1_B$2([this, (this).x,]) {}
//│     fun getB2 = (y,) => A$1_B1$3(this, y,)
//│     fun getB3 = (z,) => (this).getB2(z,)
//│     fun getA = () => A$1((this).x,)
//│   }
//│ }
//│ 

class A(x) {
  class B(y) {
    class C(z) {
      fun sum = x + y + z
    }
  }
}
//│ |#class| |A|(|x|)| |{|→|#class| |B|(|y|)| |{|→|#class| |C|(|z|)| |{|→|#fun| |sum| |#=| |x| |+| |y| |+| |z|←|↵|}|←|↵|}|←|↵|}|
//│ Parsed: {class A(x,) {class B(y,) {class C(z,) {fun sum = +(+(x, y,), z,)}}}}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(x)))))),None,None,List(),None,None,TypingUnit(List(NuTypeDef(Cls,TypeName(B),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(y)))))),None,None,List(),None,None,TypingUnit(List(NuTypeDef(Cls,TypeName(C),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(z)))))),None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(sum),None,List(),Left(App(Var(+),Tup(List((None,Fld(FldFlags(false,false,false),App(Var(+),Tup(List((None,Fld(FldFlags(false,false,false),Var(x))), (None,Fld(FldFlags(false,false,false),Var(y)))))))), (None,Fld(FldFlags(false,false,false),Var(z)))))))))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1_B$2_C$3([par$A$1_B$2, z, x,]) {
//│     fun sum = () => +(+((this).x, ((this).par$A$1_B$2).y,), (this).z,)
//│   }
//│   class A$1_B$2([par$A$1, y,]) {}
//│   class A$1([x,]) {}
//│ }
//│ 


class A(x) {
  class B{
    fun foo = 1
    fun bar = 11
  }
  fun getB = new B{
    fun foo = 2
    fun bar = 12
  }
  fun bar = 13
}
class C: A{
  fun getB = new B{
    fun foo = 3
    fun bar = 14
  }
  fun bar = 15
}
new C{
  fun getB = new B{
    fun foo = 4
    fun bar = 16
  }
  fun bar = 17
}
//│ |#class| |A|(|x|)| |{|→|#class| |B|{|→|#fun| |foo| |#=| |1|↵|#fun| |bar| |#=| |11|←|↵|}|↵|#fun| |getB| |#=| |#new| |B|{|→|#fun| |foo| |#=| |2|↵|#fun| |bar| |#=| |12|←|↵|}|↵|#fun| |bar| |#=| |13|←|↵|}|↵|#class| |C|#:| |A|{|→|#fun| |getB| |#=| |#new| |B|{|→|#fun| |foo| |#=| |3|↵|#fun| |bar| |#=| |14|←|↵|}|↵|#fun| |bar| |#=| |15|←|↵|}|↵|#new| |C|{|→|#fun| |getB| |#=| |#new| |B|{|→|#fun| |foo| |#=| |4|↵|#fun| |bar| |#=| |16|←|↵|}|↵|#fun| |bar| |#=| |17|←|↵|}|
//│ Parsed: {class A(x,) {class B {fun foo = 1; fun bar = 11}; fun getB = new B { ‹fun foo = 2; fun bar = 12› }; fun bar = 13}; class C: A {fun getB = new B { ‹fun foo = 3; fun bar = 14› }; fun bar = 15}; new C { ‹fun getB = new B { ‹fun foo = 4; fun bar = 16› }; fun bar = 17› }}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(x)))))),None,None,List(),None,None,TypingUnit(List(NuTypeDef(Cls,TypeName(B),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(IntLit(1))), NuFunDef(None,Var(bar),None,List(),Left(IntLit(11)))))), NuFunDef(None,Var(getB),None,List(),Left(Rft(NuNew(Var(B)),TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(IntLit(2))), NuFunDef(None,Var(bar),None,List(),Left(IntLit(12)))))))), NuFunDef(None,Var(bar),None,List(),Left(IntLit(13)))))), NuTypeDef(Cls,TypeName(C),List(),None,None,Some(TypeName(A)),List(),None,None,TypingUnit(List(NuFunDef(None,Var(getB),None,List(),Left(Rft(NuNew(Var(B)),TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(IntLit(3))), NuFunDef(None,Var(bar),None,List(),Left(IntLit(14)))))))), NuFunDef(None,Var(bar),None,List(),Left(IntLit(15)))))), Rft(NuNew(Var(C)),TypingUnit(List(NuFunDef(None,Var(getB),None,List(),Left(Rft(NuNew(Var(B)),TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(IntLit(4))), NuFunDef(None,Var(bar),None,List(),Left(IntLit(16)))))))), NuFunDef(None,Var(bar),None,List(),Left(IntLit(17))))))))
//│ Lifted:
//│ Lifting failed: mlscript.codegen.CodeGenError: Cannot find type B. Class values are not supported in lifter. 
//│ 



class Parent<T, U, V>(x) { 
  fun foo(x: Int): T = x+1
  class Inner<W>(y: Int){
    fun bar(z: U) = foo(y)
    fun boo(z: W) = z
  }
}
//│ |#class| |Parent|‹|T|,| |U|,| |V|›|(|x|)| |{| |→|#fun| |foo|(|x|#:| |Int|)|#:| |T| |#=| |x|+|1|↵|#class| |Inner|‹|W|›|(|y|#:| |Int|)|{|→|#fun| |bar|(|z|#:| |U|)| |#=| |foo|(|y|)|↵|#fun| |boo|(|z|#:| |W|)| |#=| |z|←|↵|}|←|↵|}|
//│ Parsed: {class Parent‹T, U, V›(x,) {fun foo = (x: Int,) => +(x, 1,) : T; class Inner‹W›(y: Int,) {fun bar = (z: U,) => foo(y,); fun boo = (z: W,) => z}}}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(Parent),List((None,TypeName(T)), (None,TypeName(U)), (None,TypeName(V))),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(x)))))),None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((Some(Var(x)),Fld(FldFlags(false,false,false),Var(Int))))),Asc(App(Var(+),Tup(List((None,Fld(FldFlags(false,false,false),Var(x))), (None,Fld(FldFlags(false,false,false),IntLit(1)))))),TypeName(T))))), NuTypeDef(Cls,TypeName(Inner),List((None,TypeName(W))),Some(Tup(List((Some(Var(y)),Fld(FldFlags(false,false,false),Var(Int)))))),None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(bar),None,List(),Left(Lam(Tup(List((Some(Var(z)),Fld(FldFlags(false,false,false),Var(U))))),App(Var(foo),Tup(List((None,Fld(FldFlags(false,false,false),Var(y))))))))), NuFunDef(None,Var(boo),None,List(),Left(Lam(Tup(List((Some(Var(z)),Fld(FldFlags(false,false,false),Var(W))))),Var(z))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class Parent$1_Inner$2[W,U]([par$Parent$1, y: Int,]) {
//│     fun bar = (z: U,) => ((this).par$Parent$1).foo((this).y,)
//│     fun boo = (z: W,) => z
//│   }
//│   class Parent$1[T,U,V]([x,]) {fun foo = (x: Int,) => +(x, 1,) : T}
//│ }
//│ 


class B<T> {}
class C {}
class D(y: Int) {}
class A<T, U>(x: Int): ({a1: Int} & B<T> & D(x)) {
  fun getA() = new C{
    fun foo(x: T) = x
  }
}
//│ |#class| |B|‹|T|›| |{||}|↵|#class| |C| |{||}|↵|#class| |D|(|y|#:| |Int|)| |{||}|↵|#class| |A|‹|T|,| |U|›|(|x|#:| |Int|)|#:| |(|{|a1|#:| |Int|}| |&| |B|‹|T|›| |&| |D|(|x|)|)| |{|→|#fun| |getA|(||)| |#=| |#new| |C|{|→|#fun| |foo|(|x|#:| |T|)| |#=| |x|←|↵|}|←|↵|}|
//│ Parsed: {class B‹T› {}; class C {}; class D(y: Int,) {}; class A‹T, U›(x: Int,): {a1: Int} & B[T] & D[x] {fun getA = () => new C { ‹fun foo = (x: T,) => x› }}}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(B),List((None,TypeName(T))),None,None,None,List(),None,None,TypingUnit(List())), NuTypeDef(Cls,TypeName(C),List(),None,None,None,List(),None,None,TypingUnit(List())), NuTypeDef(Cls,TypeName(D),List(),Some(Tup(List((Some(Var(y)),Fld(FldFlags(false,false,false),Var(Int)))))),None,None,List(),None,None,TypingUnit(List())), NuTypeDef(Cls,TypeName(A),List((None,TypeName(T)), (None,TypeName(U))),Some(Tup(List((Some(Var(x)),Fld(FldFlags(false,false,false),Var(Int)))))),None,Some(Inter(Inter(Record(List((Var(a1),Field(None,TypeName(Int))))),AppliedType(TypeName(B),List(TypeName(T)))),AppliedType(TypeName(D),List(TypeName(x))))),List(),None,None,TypingUnit(List(NuFunDef(None,Var(getA),None,List(),Left(Lam(Tup(List()),Rft(NuNew(Var(C)),TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((Some(Var(x)),Fld(FldFlags(false,false,false),Var(T))))),Var(x)))))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class B$1[T]([]) {}
//│   class C$2([]) {}
//│   class D$3([y: Int,]) {}
//│   class A$4[T,U]([x: Int,]) {fun getA = () => new C$2([]) {}}
//│ }
//│ 
// │ TypingUnit(NuTypeDef(class, B, (TypeName(T)), Tup(), (), TypingUnit()), NuTypeDef(class, C, (), Tup(), (), TypingUnit()), NuTypeDef(class, A, (TypeName(T), TypeName(U)), Tup(x: Var(Int)), (App(App(Var(&), Tup(_: Bra(rcd = true, Rcd(Var(a1) = Var(Int)})))), Tup(_: TyApp(Var(B), List(TypeName(T)))))), TypingUnit(NuFunDef(None, getA, [], Lam(Tup(), New(Some((TypeName(C),)), TypingUnit(List(fun foo = x: T, => x))))))))

class B<T> {}
class C {}
class D(y: Int) {}
class A<T, U>(x: Int) extends {a1: Int}, B<T>, D(x){
  fun getA() = new C{
    fun foo(x) = x
  }
}
//│ |#class| |B|‹|T|›| |{||}|↵|#class| |C| |{||}|↵|#class| |D|(|y|#:| |Int|)| |{||}|↵|#class| |A|‹|T|,| |U|›|(|x|#:| |Int|)| |#extends| |{|a1|#:| |Int|}|,| |B|‹|T|›|,| |D|(|x|)|{|→|#fun| |getA|(||)| |#=| |#new| |C|{|→|#fun| |foo|(|x|)| |#=| |x|←|↵|}|←|↵|}|
//│ Parsed: {class B‹T› {}; class C {}; class D(y: Int,) {}; class A‹T, U›(x: Int,): '{' {a1: Int} '}', B‹T›, D(x,) {fun getA = () => new C { ‹fun foo = (x,) => x› }}}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(B),List((None,TypeName(T))),None,None,None,List(),None,None,TypingUnit(List())), NuTypeDef(Cls,TypeName(C),List(),None,None,None,List(),None,None,TypingUnit(List())), NuTypeDef(Cls,TypeName(D),List(),Some(Tup(List((Some(Var(y)),Fld(FldFlags(false,false,false),Var(Int)))))),None,None,List(),None,None,TypingUnit(List())), NuTypeDef(Cls,TypeName(A),List((None,TypeName(T)), (None,TypeName(U))),Some(Tup(List((Some(Var(x)),Fld(FldFlags(false,false,false),Var(Int)))))),None,None,List(Bra(true,Rcd(List((Var(a1),Fld(FldFlags(false,false,false),Var(Int)))))), TyApp(Var(B),List(TypeName(T))), App(Var(D),Tup(List((None,Fld(FldFlags(false,false,false),Var(x))))))),None,None,TypingUnit(List(NuFunDef(None,Var(getA),None,List(),Left(Lam(Tup(List()),Rft(NuNew(Var(C)),TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(FldFlags(false,false,false),Var(x))))),Var(x)))))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class B$1[T]([]) {}
//│   class C$2([]) {}
//│   class D$3([y: Int,]) {}
//│   class A$4[T,U]([x: Int,]): '{' {a1: Int} '}', B$1()‹T›, D$3((this).x,) {fun getA = () => new C$2([]) {}}
//│ }
//│ 

class Child<T, U>(x): ({ age: T } & { name: String}) {
  class Inner{
    fun foo = age
  }
  fun bar = age
  fun boo = new Inner
}
//│ |#class| |Child|‹|T|,| |U|›|(|x|)|#:| |(|{| |age|#:| |T| |}| |&| |{| |name|#:| |String|}|)| |{|→|#class| |Inner|{|→|#fun| |foo| |#=| |age|←|↵|}|↵|#fun| |bar| |#=| |age|↵|#fun| |boo| |#=| |#new| |Inner|←|↵|}|
//│ Parsed: {class Child‹T, U›(x,): {age: T} & {name: String} {class Inner {fun foo = age}; fun bar = age; fun boo = new Inner}}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(Child),List((None,TypeName(T)), (None,TypeName(U))),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(x)))))),None,Some(Inter(Record(List((Var(age),Field(None,TypeName(T))))),Record(List((Var(name),Field(None,TypeName(String))))))),List(),None,None,TypingUnit(List(NuTypeDef(Cls,TypeName(Inner),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(Var(age)))))), NuFunDef(None,Var(bar),None,List(),Left(Var(age))), NuFunDef(None,Var(boo),None,List(),Left(NuNew(Var(Inner)))))))))
//│ Lifted:
//│ TypingUnit {
//│   class Child$1_Inner$2([par$Child$1, age,]) {fun foo = () => (this).age}
//│   class Child$1[T,U]([x,]) {
//│     fun bar = () => age
//│     fun boo = () => new Child$1_Inner$2([this, age,]) {}
//│   }
//│ }
//│ 


class A(x: Int) {
  fun getA: Int = 0
  fun getA1 = 1
}
new A(0) {
  fun getA = 3
  fun getA2 = 2
}
//│ |#class| |A|(|x|#:| |Int|)| |{|→|#fun| |getA|#:| |Int| |#=| |0|↵|#fun| |getA1| |#=| |1|←|↵|}|↵|#new| |A|(|0|)| |{|→|#fun| |getA| |#=| |3|↵|#fun| |getA2| |#=| |2|←|↵|}|
//│ Parsed: {class A(x: Int,) {fun getA = 0 : Int; fun getA1 = 1}; (new A)(0,) { ‹fun getA = 3; fun getA2 = 2› }}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),Some(Tup(List((Some(Var(x)),Fld(FldFlags(false,false,false),Var(Int)))))),None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(getA),None,List(),Left(Asc(IntLit(0),TypeName(Int)))), NuFunDef(None,Var(getA1),None,List(),Left(IntLit(1)))))), Rft(App(NuNew(Var(A)),Tup(List((None,Fld(FldFlags(false,false,false),IntLit(0)))))),TypingUnit(List(NuFunDef(None,Var(getA),None,List(),Left(IntLit(3))), NuFunDef(None,Var(getA2),None,List(),Left(IntLit(2))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1([x: Int,]) {fun getA = () => 0 : Int; fun getA1 = () => 1}
//│   class A$1$2([x: Int,]): A$1((this).x,) {fun getA = () => 3; fun getA2 = () => 2}
//│   Code(List({new A$1$2([0,]) {}}))
//│ }
//│ 


class A(x) {
  class B(y) {  }
}
new A(1) {
  fun getB = new B(2){
    fun getB = new B(3)
  }
}
//│ |#class| |A|(|x|)| |{|→|#class| |B|(|y|)| |{| |}|←|↵|}|↵|#new| |A|(|1|)| |{|→|#fun| |getB| |#=| |#new| |B|(|2|)|{|→|#fun| |getB| |#=| |#new| |B|(|3|)|←|↵|}|←|↵|}|
//│ Parsed: {class A(x,) {class B(y,) {}}; (new A)(1,) { ‹fun getB = (new B)(2,) { ‹fun getB = (new B)(3,)› }› }}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(x)))))),None,None,List(),None,None,TypingUnit(List(NuTypeDef(Cls,TypeName(B),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(y)))))),None,None,List(),None,None,TypingUnit(List()))))), Rft(App(NuNew(Var(A)),Tup(List((None,Fld(FldFlags(false,false,false),IntLit(1)))))),TypingUnit(List(NuFunDef(None,Var(getB),None,List(),Left(Rft(App(NuNew(Var(B)),Tup(List((None,Fld(FldFlags(false,false,false),IntLit(2)))))),TypingUnit(List(NuFunDef(None,Var(getB),None,List(),Left(App(NuNew(Var(B)),Tup(List((None,Fld(FldFlags(false,false,false),IntLit(3))))))))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1_B$2([par$A$1, y,]) {}
//│   class A$1([x,]) {}
//│   class A$1$3_B$2$4([par$A$1$3, y,]): A$1_B$2((this).par$A$1$3, (this).y,) {fun getB = () => new A$1_B$2([(this).par$A$1$3, 3,]) {}}
//│   class A$1$3([x,]): A$1((this).x,) {fun getB = () => {new A$1$3_B$2$4([this, 2,]) {}}}
//│   Code(List({new A$1$3([1,]) {}}))
//│ }
//│ 



class A {
  fun getA = 0
  fun funcA = 10
}
class B: A{
  fun getA = 1
  fun funcB = 11
}
new A
new B
fun f(x) = if x is A then 0 else 1
f(new A{
  fun getA = 2
})
new B{
  fun getA = funcB
}
//│ |#class| |A| |{|→|#fun| |getA| |#=| |0|↵|#fun| |funcA| |#=| |10|←|↵|}|↵|#class| |B|#:| |A|{|→|#fun| |getA| |#=| |1|↵|#fun| |funcB| |#=| |11|←|↵|}|↵|#new| |A|↵|#new| |B|↵|#fun| |f|(|x|)| |#=| |#if| |x| |is| |A| |#then| |0| |#else| |1|↵|f|(|#new| |A|{|→|#fun| |getA| |#=| |2|←|↵|}|)|↵|#new| |B|{|→|#fun| |getA| |#=| |funcB|←|↵|}|
//│ Parsed: {class A {fun getA = 0; fun funcA = 10}; class B: A {fun getA = 1; fun funcB = 11}; new A; new B; fun f = (x,) => if (is(x, A,)) then 0 else 1; f(new A { ‹fun getA = 2› },); new B { ‹fun getA = funcB› }}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(getA),None,List(),Left(IntLit(0))), NuFunDef(None,Var(funcA),None,List(),Left(IntLit(10)))))), NuTypeDef(Cls,TypeName(B),List(),None,None,Some(TypeName(A)),List(),None,None,TypingUnit(List(NuFunDef(None,Var(getA),None,List(),Left(IntLit(1))), NuFunDef(None,Var(funcB),None,List(),Left(IntLit(11)))))), NuNew(Var(A)), NuNew(Var(B)), NuFunDef(None,Var(f),None,List(),Left(Lam(Tup(List((None,Fld(FldFlags(false,false,false),Var(x))))),If(IfThen(App(Var(is),Tup(List((None,Fld(FldFlags(false,false,false),Var(x))), (None,Fld(FldFlags(false,false,false),Var(A)))))),IntLit(0)),Some(IntLit(1)))))), App(Var(f),Tup(List((None,Fld(FldFlags(false,false,false),Rft(NuNew(Var(A)),TypingUnit(List(NuFunDef(None,Var(getA),None,List(),Left(IntLit(2))))))))))), Rft(NuNew(Var(B)),TypingUnit(List(NuFunDef(None,Var(getA),None,List(),Left(Var(funcB))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1([]) {fun getA = () => 0; fun funcA = () => 10}
//│   class B$2([]) {fun getA = () => 1; fun funcB = () => 11}
//│   fun f$1 = (x,) => if (is(x, A$1(),)) then 0 else 1
//│   Code(List(new A$1([]) {}))
//│   Code(List(new B$2([]) {}))
//│   Code(List(f$1(new A$1([]) {},)))
//│   Code(List(new B$2([]) {}))
//│ }
//│ 


class A{
  class B{
    fun funB = 1
    fun foo = 100
  }
  class C: B{
    fun funC = 2
    fun foo = 1000
  }
  class D{
    fun funD = 3
    fun foo = 10000    
    class E: C{
      fun funE = 4
      fun foo = 100000
    }
    class F: E{
      fun funF = 5
      fun foo = 1000000
    }
  }
}
//│ |#class| |A|{|→|#class| |B|{|→|#fun| |funB| |#=| |1|↵|#fun| |foo| |#=| |100|←|↵|}|↵|#class| |C|#:| |B|{|→|#fun| |funC| |#=| |2|↵|#fun| |foo| |#=| |1000|←|↵|}|↵|#class| |D|{|→|#fun| |funD| |#=| |3|↵|#fun| |foo| |#=| |10000| |↵|#class| |E|#:| |C|{|→|#fun| |funE| |#=| |4|↵|#fun| |foo| |#=| |100000|←|↵|}|↵|#class| |F|#:| |E|{|→|#fun| |funF| |#=| |5|↵|#fun| |foo| |#=| |1000000|←|↵|}|←|↵|}|←|↵|}|
//│ Parsed: {class A {class B {fun funB = 1; fun foo = 100}; class C: B {fun funC = 2; fun foo = 1000}; class D {fun funD = 3; fun foo = 10000; class E: C {fun funE = 4; fun foo = 100000}; class F: E {fun funF = 5; fun foo = 1000000}}}}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),None,None,None,List(),None,None,TypingUnit(List(NuTypeDef(Cls,TypeName(B),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(funB),None,List(),Left(IntLit(1))), NuFunDef(None,Var(foo),None,List(),Left(IntLit(100)))))), NuTypeDef(Cls,TypeName(C),List(),None,None,Some(TypeName(B)),List(),None,None,TypingUnit(List(NuFunDef(None,Var(funC),None,List(),Left(IntLit(2))), NuFunDef(None,Var(foo),None,List(),Left(IntLit(1000)))))), NuTypeDef(Cls,TypeName(D),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(funD),None,List(),Left(IntLit(3))), NuFunDef(None,Var(foo),None,List(),Left(IntLit(10000))), NuTypeDef(Cls,TypeName(E),List(),None,None,Some(TypeName(C)),List(),None,None,TypingUnit(List(NuFunDef(None,Var(funE),None,List(),Left(IntLit(4))), NuFunDef(None,Var(foo),None,List(),Left(IntLit(100000)))))), NuTypeDef(Cls,TypeName(F),List(),None,None,Some(TypeName(E)),List(),None,None,TypingUnit(List(NuFunDef(None,Var(funF),None,List(),Left(IntLit(5))), NuFunDef(None,Var(foo),None,List(),Left(IntLit(1000000))))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1_B$2([par$A$1,]) {fun funB = () => 1; fun foo = () => 100}
//│   class A$1_C$3([par$A$1,]) {fun funC = () => 2; fun foo = () => 1000}
//│   class A$1_D$4_E$5([par$A$1_D$4,]) {fun funE = () => 4; fun foo = () => 100000}
//│   class A$1_D$4_F$6([par$A$1_D$4,]) {fun funF = () => 5; fun foo = () => 1000000}
//│   class A$1_D$4([par$A$1,]) {fun funD = () => 3; fun foo = () => 10000}
//│   class A$1([]) {}
//│ }
//│ 


class A{
  class B{
    fun funB = 1
    fun foo = 100
  }
  class C: B{
    fun funC = 2
    fun foo = 1000
    fun getB = new B
  }
  class D{
    fun funD = 3
    fun foo = 10000    
    class E: C{
      fun funE = 4
      fun foo = 100000
      fun getD = new D
    }
    class F: E{
      fun funF = 5
      fun foo = 1000000
      fun getE = new E{
        fun foo = 0
      }
    }
  }
}
//│ |#class| |A|{|→|#class| |B|{|→|#fun| |funB| |#=| |1|↵|#fun| |foo| |#=| |100|←|↵|}|↵|#class| |C|#:| |B|{|→|#fun| |funC| |#=| |2|↵|#fun| |foo| |#=| |1000|↵|#fun| |getB| |#=| |#new| |B|←|↵|}|↵|#class| |D|{|→|#fun| |funD| |#=| |3|↵|#fun| |foo| |#=| |10000| |↵|#class| |E|#:| |C|{|→|#fun| |funE| |#=| |4|↵|#fun| |foo| |#=| |100000|↵|#fun| |getD| |#=| |#new| |D|←|↵|}|↵|#class| |F|#:| |E|{|→|#fun| |funF| |#=| |5|↵|#fun| |foo| |#=| |1000000|↵|#fun| |getE| |#=| |#new| |E|{|→|#fun| |foo| |#=| |0|←|↵|}|←|↵|}|←|↵|}|←|↵|}|
//│ Parsed: {class A {class B {fun funB = 1; fun foo = 100}; class C: B {fun funC = 2; fun foo = 1000; fun getB = new B}; class D {fun funD = 3; fun foo = 10000; class E: C {fun funE = 4; fun foo = 100000; fun getD = new D}; class F: E {fun funF = 5; fun foo = 1000000; fun getE = new E { ‹fun foo = 0› }}}}}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),None,None,None,List(),None,None,TypingUnit(List(NuTypeDef(Cls,TypeName(B),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(funB),None,List(),Left(IntLit(1))), NuFunDef(None,Var(foo),None,List(),Left(IntLit(100)))))), NuTypeDef(Cls,TypeName(C),List(),None,None,Some(TypeName(B)),List(),None,None,TypingUnit(List(NuFunDef(None,Var(funC),None,List(),Left(IntLit(2))), NuFunDef(None,Var(foo),None,List(),Left(IntLit(1000))), NuFunDef(None,Var(getB),None,List(),Left(NuNew(Var(B))))))), NuTypeDef(Cls,TypeName(D),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(funD),None,List(),Left(IntLit(3))), NuFunDef(None,Var(foo),None,List(),Left(IntLit(10000))), NuTypeDef(Cls,TypeName(E),List(),None,None,Some(TypeName(C)),List(),None,None,TypingUnit(List(NuFunDef(None,Var(funE),None,List(),Left(IntLit(4))), NuFunDef(None,Var(foo),None,List(),Left(IntLit(100000))), NuFunDef(None,Var(getD),None,List(),Left(NuNew(Var(D))))))), NuTypeDef(Cls,TypeName(F),List(),None,None,Some(TypeName(E)),List(),None,None,TypingUnit(List(NuFunDef(None,Var(funF),None,List(),Left(IntLit(5))), NuFunDef(None,Var(foo),None,List(),Left(IntLit(1000000))), NuFunDef(None,Var(getE),None,List(),Left(Rft(NuNew(Var(E)),TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(IntLit(0)))))))))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1_B$2([par$A$1,]) {fun funB = () => 1; fun foo = () => 100}
//│   class A$1_C$3([par$A$1,]) {
//│     fun funC = () => 2
//│     fun foo = () => 1000
//│     fun getB = () => new A$1_B$2([(this).par$A$1,]) {}
//│   }
//│   class A$1_D$4_E$5([par$A$1_D$4,]) {
//│     fun funE = () => 4
//│     fun foo = () => 100000
//│     fun getD = () => new A$1_D$4([((this).par$A$1_D$4).par$A$1,]) {}
//│   }
//│   class A$1_D$4_F$6([par$A$1_D$4,]) {
//│     fun funF = () => 5
//│     fun foo = () => 1000000
//│     fun getE = () => new A$1_D$4_E$5([(this).par$A$1_D$4,]) {}
//│   }
//│   class A$1_D$4([par$A$1,]) {fun funD = () => 3; fun foo = () => 10000}
//│   class A$1([]) {}
//│ }
//│ 


class A{
  class B{
    fun foo = 1
  }
  fun bar = new B
}
new A
//│ |#class| |A|{|→|#class| |B|{|→|#fun| |foo| |#=| |1|←|↵|}|↵|#fun| |bar| |#=| |#new| |B|←|↵|}|↵|#new| |A|
//│ Parsed: {class A {class B {fun foo = 1}; fun bar = new B}; new A}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),None,None,None,List(),None,None,TypingUnit(List(NuTypeDef(Cls,TypeName(B),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(IntLit(1)))))), NuFunDef(None,Var(bar),None,List(),Left(NuNew(Var(B))))))), NuNew(Var(A))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1_B$2([par$A$1,]) {fun foo = () => 1}
//│   class A$1([]) {fun bar = () => new A$1_B$2([this,]) {}}
//│   Code(List(new A$1([]) {}))
//│ }
//│ 


class A(x) {
  fun foo = 0
  fun bar = x
}
let x = new A{
  fun foo = 1
  fun newFun = 2
  fun bar = new A(foo){
    fun foo = bar + 1
    fun bar2 = newFun + 1
  }
}
//│ |#class| |A|(|x|)| |{|→|#fun| |foo| |#=| |0|↵|#fun| |bar| |#=| |x|←|↵|}|↵|#let| |x| |#=| |#new| |A|{|→|#fun| |foo| |#=| |1|↵|#fun| |newFun| |#=| |2|↵|#fun| |bar| |#=| |#new| |A|(|foo|)|{|→|#fun| |foo| |#=| |bar| |+| |1|↵|#fun| |bar2| |#=| |newFun| |+| |1|←|↵|}|←|↵|}|
//│ Parsed: {class A(x,) {fun foo = 0; fun bar = x}; let x = new A { ‹fun foo = 1; fun newFun = 2; fun bar = (new A)(foo,) { ‹fun foo = +(bar, 1,); fun bar2 = +(newFun, 1,)› }› }}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),Some(Tup(List((None,Fld(FldFlags(false,false,false),Var(x)))))),None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(IntLit(0))), NuFunDef(None,Var(bar),None,List(),Left(Var(x)))))), NuFunDef(Some(false),Var(x),None,List(),Left(Rft(NuNew(Var(A)),TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(IntLit(1))), NuFunDef(None,Var(newFun),None,List(),Left(IntLit(2))), NuFunDef(None,Var(bar),None,List(),Left(Rft(App(NuNew(Var(A)),Tup(List((None,Fld(FldFlags(false,false,false),Var(foo)))))),TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(App(Var(+),Tup(List((None,Fld(FldFlags(false,false,false),Var(bar))), (None,Fld(FldFlags(false,false,false),IntLit(1)))))))), NuFunDef(None,Var(bar2),None,List(),Left(App(Var(+),Tup(List((None,Fld(FldFlags(false,false,false),Var(newFun))), (None,Fld(FldFlags(false,false,false),IntLit(1))))))))))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1([x,]) {fun foo = () => 0; fun bar = () => (this).x}
//│   let x$1 = () => new A$1([]) {}
//│ }
//│ 

class A {}
new A{
  fun foo = 1
  fun bar = new A{
    fun foo1 = foo
    fun bar1 = new A{
      fun foo2 = foo
      fun bar2 = new A{
        fun foo3 = foo
        fun bar3 = new A{
          fun foo4 = foo
          fun bar4 = 0
        }
      }
    }
  }
}
//│ |#class| |A| |{||}|↵|#new| |A|{|→|#fun| |foo| |#=| |1|↵|#fun| |bar| |#=| |#new| |A|{|→|#fun| |foo1| |#=| |foo|↵|#fun| |bar1| |#=| |#new| |A|{|→|#fun| |foo2| |#=| |foo|↵|#fun| |bar2| |#=| |#new| |A|{|→|#fun| |foo3| |#=| |foo|↵|#fun| |bar3| |#=| |#new| |A|{|→|#fun| |foo4| |#=| |foo|↵|#fun| |bar4| |#=| |0|←|↵|}|←|↵|}|←|↵|}|←|↵|}|←|↵|}|
//│ Parsed: {class A {}; new A { ‹fun foo = 1; fun bar = new A { ‹fun foo1 = foo; fun bar1 = new A { ‹fun foo2 = foo; fun bar2 = new A { ‹fun foo3 = foo; fun bar3 = new A { ‹fun foo4 = foo; fun bar4 = 0› }› }› }› }› }}
//│ Parsed:
//│ TypingUnit(List(NuTypeDef(Cls,TypeName(A),List(),None,None,None,List(),None,None,TypingUnit(List())), Rft(NuNew(Var(A)),TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(IntLit(1))), NuFunDef(None,Var(bar),None,List(),Left(Rft(NuNew(Var(A)),TypingUnit(List(NuFunDef(None,Var(foo1),None,List(),Left(Var(foo))), NuFunDef(None,Var(bar1),None,List(),Left(Rft(NuNew(Var(A)),TypingUnit(List(NuFunDef(None,Var(foo2),None,List(),Left(Var(foo))), NuFunDef(None,Var(bar2),None,List(),Left(Rft(NuNew(Var(A)),TypingUnit(List(NuFunDef(None,Var(foo3),None,List(),Left(Var(foo))), NuFunDef(None,Var(bar3),None,List(),Left(Rft(NuNew(Var(A)),TypingUnit(List(NuFunDef(None,Var(foo4),None,List(),Left(Var(foo))), NuFunDef(None,Var(bar4),None,List(),Left(IntLit(0))))))))))))))))))))))))))))
//│ Lifted:
//│ TypingUnit {class A$1([]) {}; Code(List(new A$1([]) {}))}
//│ 

