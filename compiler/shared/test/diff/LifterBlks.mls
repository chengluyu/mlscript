:NewDefs
:ParseOnly

fun foo =
  print("ok")
  print("ko")
//│ |#fun| |foo| |#=|→|print|(|"ok"|)|↵|print|(|"ko"|)|←|
//│ Parsed: {fun foo = {print("ok",); print("ko",)}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, N, Nil, L(Blk(App(Var("print"), Tup((N, StrLit(ok)))), App(Var("print"), Tup((N, StrLit(ko))))))))
//│ Lifted:
//│ TypingUnit {fun foo$1 = () => {print("ok",); print("ko",)}}
//│ 

class A{
  class B {}
  fun foo(x: B) = (x : B)
}
//│ |#class| |A|{|→|#class| |B| |{||}|↵|#fun| |foo|(|x|#:| |B|)| |#=| |(|x| |#:| |B|)|←|↵|}|
//│ Parsed: {class A {class B {}; fun foo = (x: B,) => '(' x : B ')'}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("A"), Ls(), N, N, N, Ls(), N, N, TypingUnit(NuTypeDef(Cls, TypeName("B"), Ls(), N, N, N, Ls(), N, N, TypingUnit()), NuFunDef(None, foo, N, Nil, L(Lam(Tup((S(Var("x")), Var("B"))), Bra(rcd = false, Asc(Var("x"), TypeName(B)))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1_B$2([par$A$1,]) {}
//│   class A$1([]) {fun foo = (x: A$1_B$2,) => '(' x : A$1_B$2 ')'}
//│ }
//│ 

fun foo =
  let local(x) =
    class Foo {
      fun bar = x + 1
    }
    Foo().bar
  print of local(0) + local(1)
  print of (local of 0) + local of 1
  fun tmp = 1
  print of local of 0 + local of 1
  fun tmp = 2
//│ |#fun| |foo| |#=|→|#let| |local|(|x|)| |#=|→|#class| |Foo| |{|→|#fun| |bar| |#=| |x| |+| |1|←|↵|}|↵|Foo|(||)|.bar|←|↵|print| |#of| |local|(|0|)| |+| |local|(|1|)|↵|print| |#of| |(|local| |#of| |0|)| |+| |local| |#of| |1|↵|#fun| |tmp| |#=| |1|↵|print| |#of| |local| |#of| |0| |+| |local| |#of| |1|↵|#fun| |tmp| |#=| |2|←|
//│ Parsed: {fun foo = {let local = (x,) => {class Foo {fun bar = +(x, 1,)}; (Foo()).bar}; print(+(local(0,), local(1,),),); print(+('(' local(0,) ')', local(1,),),); fun tmp = 1; print(local(+(0, local(1,),),),); fun tmp = 2}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, N, Nil, L(Blk(NuFunDef(Some(false), local, N, Nil, L(Lam(Tup((N, Var("x"))), Blk(NuTypeDef(Cls, TypeName("Foo"), Ls(), N, N, N, Ls(), N, N, TypingUnit(NuFunDef(None, bar, N, Nil, L(App(Var("+"), Tup((N, Var("x")), (N, IntLit(1)))))))), Sel(App(Var("Foo"), Tup()), bar))))), App(Var("print"), Tup((N, App(Var("+"), Tup((N, App(Var("local"), Tup((N, IntLit(0))))), (N, App(Var("local"), Tup((N, IntLit(1)))))))))), App(Var("print"), Tup((N, App(Var("+"), Tup((N, Bra(rcd = false, App(Var("local"), Tup((N, IntLit(0)))))), (N, App(Var("local"), Tup((N, IntLit(1)))))))))), NuFunDef(None, tmp, N, Nil, L(IntLit(1))), App(Var("print"), Tup((N, App(Var("local"), Tup((N, App(Var("+"), Tup((N, IntLit(0)), (N, App(Var("local"), Tup((N, IntLit(1))))))))))))), NuFunDef(None, tmp, N, Nil, L(IntLit(2)))))))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1([x,]) {fun bar = () => +((this).x, 1,)}
//│   let local$3 = (x,) => {(Foo$1(x,)).bar}
//│   fun tmp$2 = () => 1
//│   fun foo$1 = () => {print(+(local$3(0,), local$3(1,),),); print(+('(' local$3(0,) ')', local$3(1,),),); print(local$3(+(0, local$3(1,),),),)}
//│ }
//│ 

class A(y){}
let f = x => new A(0){fun bar = x+y}
f(0)
//│ |#class| |A|(|y|)|{||}|↵|#let| |f| |#=| |x| |#=>| |#new| |A|(|0|)|{|#fun| |bar| |#=| |x|+|y|}|↵|f|(|0|)|
//│ Parsed: {class A(y,) {}; let f = (x,) => (new A)(0,) { ‹fun bar = +(x, y,)› }; f(0,)}
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("A"), Ls(), S(Tup((N, Var("y")))), N, N, Ls(), N, N, TypingUnit()), NuFunDef(Some(false), f, N, Nil, L(Lam(Tup((N, Var("x"))), Rft(App(NuNew(Var("A")), Tup((N, IntLit(0)))), TypingUnit(NuFunDef(None, bar, N, Nil, L(App(Var("+"), Tup((N, Var("x")), (N, Var("y"))))))))))), App(Var("f"), Tup((N, IntLit(0)))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1([y,]) {}
//│   class A$2$2([y, x,]): A$1((this).y,) {fun bar = () => +((this).x, (this).y,)}
//│   let f$1 = (x,) => {new A$2$2([0, x,]) {}}
//│   Code(List(f$1(0,)))
//│ }
//│ 

class A(x){
  fun w = x
  fun foo(y) = 
    class B(z){
      fun bar = x+y+z
    }
    new B(0){
      fun bar = w+y+z
    }
}
//│ |#class| |A|(|x|)|{|→|#fun| |w| |#=| |x|↵|#fun| |foo|(|y|)| |#=| |→|#class| |B|(|z|)|{|→|#fun| |bar| |#=| |x|+|y|+|z|←|↵|}|↵|#new| |B|(|0|)|{|→|#fun| |bar| |#=| |w|+|y|+|z|←|↵|}|←|←|↵|}|
//│ Parsed: {class A(x,) {fun w = x; fun foo = (y,) => {class B(z,) {fun bar = +(+(x, y,), z,)}; (new B)(0,) { ‹fun bar = +(+(w, y,), z,)› }}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("A"), Ls(), S(Tup((N, Var("x")))), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, w, N, Nil, L(Var("x"))), NuFunDef(None, foo, N, Nil, L(Lam(Tup((N, Var("y"))), Blk(NuTypeDef(Cls, TypeName("B"), Ls(), S(Tup((N, Var("z")))), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, bar, N, Nil, L(App(Var("+"), Tup((N, App(Var("+"), Tup((N, Var("x")), (N, Var("y"))))), (N, Var("z")))))))), Rft(App(NuNew(Var("B")), Tup((N, IntLit(0)))), TypingUnit(NuFunDef(None, bar, N, Nil, L(App(Var("+"), Tup((N, App(Var("+"), Tup((N, Var("w")), (N, Var("y"))))), (N, Var("z")))))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1_B$2([par$A$1, z, y,]) {
//│     fun bar = () => +(+(((this).par$A$1).x, (this).y,), (this).z,)
//│   }
//│   class A$1_B$1$3([par$A$1, z, y,]): A$1_B$2((this).par$A$1, (this).z, (this).y,) {
//│     fun bar = () => +(+(((this).par$A$1).w, (this).y,), (this).z,)
//│   }
//│   class A$1([x,]) {
//│     fun w = () => (this).x
//│     fun foo = (y,) => {{new A$1_B$1$3([this, 0, y,]) {}}}
//│   }
//│ }
//│ 

fun f(x,y,z) = 
  class A{
    fun foo = new B
    fun bar1 = x
  }
  class B{
    fun foo = new A
    fun bar2 = y
  }
  class C extends A, B {
    fun bar = bar1 + bar2
  }
//│ |#fun| |f|(|x|,|y|,|z|)| |#=| |→|#class| |A|{|→|#fun| |foo| |#=| |#new| |B|↵|#fun| |bar1| |#=| |x|←|↵|}|↵|#class| |B|{|→|#fun| |foo| |#=| |#new| |A|↵|#fun| |bar2| |#=| |y|←|↵|}|↵|#class| |C| |#extends| |A|,| |B| |{|→|#fun| |bar| |#=| |bar1| |+| |bar2|←|↵|}|←|
//│ Parsed: {fun f = (x, y, z,) => {class A {fun foo = new B; fun bar1 = x}; class B {fun foo = new A; fun bar2 = y}; class C: A, B {fun bar = +(bar1, bar2,)}}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, N, Nil, L(Lam(Tup((N, Var("x")), (N, Var("y")), (N, Var("z"))), Blk(NuTypeDef(Cls, TypeName("A"), Ls(), N, N, N, Ls(), N, N, TypingUnit(NuFunDef(None, foo, N, Nil, L(NuNew(Var("B")))), NuFunDef(None, bar1, N, Nil, L(Var("x"))))), NuTypeDef(Cls, TypeName("B"), Ls(), N, N, N, Ls(), N, N, TypingUnit(NuFunDef(None, foo, N, Nil, L(NuNew(Var("A")))), NuFunDef(None, bar2, N, Nil, L(Var("y"))))), NuTypeDef(Cls, TypeName("C"), Ls(), N, N, N, Ls(Var("A"), Var("B")), N, N, TypingUnit(NuFunDef(None, bar, N, Nil, L(App(Var("+"), Tup((N, Var("bar1")), (N, Var("bar2")))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1([x, y,]) {
//│     fun foo = () => new B$2([(this).y, (this).x,]) {}
//│     fun bar1 = () => (this).x
//│   }
//│   class B$2([y, x,]) {
//│     fun foo = () => new A$1([(this).x, (this).y,]) {}
//│     fun bar2 = () => (this).y
//│   }
//│   class C$3([x, y,]): A$1((this).x, (this).y,), B$2((this).y, (this).x,) {fun bar = () => +((this).bar1, (this).bar2,)}
//│   fun f$1 = (x, y, z,) => {}
//│ }
//│ 

fun f(x,y,z) = 
  class C{
    class A{
      fun foo = new B
      fun bar1 = x
    }
    class B{
      fun foo = new A
      fun bar2 = y
    }
    fun boo = (new A).bar1 + B().bar2 + z
  }
//│ |#fun| |f|(|x|,|y|,|z|)| |#=| |→|#class| |C|{|→|#class| |A|{|→|#fun| |foo| |#=| |#new| |B|↵|#fun| |bar1| |#=| |x|←|↵|}|↵|#class| |B|{|→|#fun| |foo| |#=| |#new| |A|↵|#fun| |bar2| |#=| |y|←|↵|}|↵|#fun| |boo| |#=| |(|#new| |A|)|.bar1| |+| |B|(||)|.bar2| |+| |z|←|↵|}|←|
//│ Parsed: {fun f = (x, y, z,) => {class C {class A {fun foo = new B; fun bar1 = x}; class B {fun foo = new A; fun bar2 = y}; fun boo = +(+(('(' new A ')').bar1, (B()).bar2,), z,)}}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, N, Nil, L(Lam(Tup((N, Var("x")), (N, Var("y")), (N, Var("z"))), Blk(NuTypeDef(Cls, TypeName("C"), Ls(), N, N, N, Ls(), N, N, TypingUnit(NuTypeDef(Cls, TypeName("A"), Ls(), N, N, N, Ls(), N, N, TypingUnit(NuFunDef(None, foo, N, Nil, L(NuNew(Var("B")))), NuFunDef(None, bar1, N, Nil, L(Var("x"))))), NuTypeDef(Cls, TypeName("B"), Ls(), N, N, N, Ls(), N, N, TypingUnit(NuFunDef(None, foo, N, Nil, L(NuNew(Var("A")))), NuFunDef(None, bar2, N, Nil, L(Var("y"))))), NuFunDef(None, boo, N, Nil, L(App(Var("+"), Tup((N, App(Var("+"), Tup((N, Sel(Bra(rcd = false, NuNew(Var("A"))), bar1)), (N, Sel(App(Var("B"), Tup()), bar2))))), (N, Var("z")))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class C$1_A$2([par$C$1,]) {
//│     fun foo = () => new C$1_B$3([(this).par$C$1,]) {}
//│     fun bar1 = () => ((this).par$C$1).x
//│   }
//│   class C$1_B$3([par$C$1,]) {
//│     fun foo = () => new C$1_A$2([(this).par$C$1,]) {}
//│     fun bar2 = () => ((this).par$C$1).y
//│   }
//│   class C$1([x, y, z,]) {
//│     fun boo = () => +(+(('(' new C$1_A$2([this,]) {} ')').bar1, (C$1_B$3(this,)).bar2,), (this).z,)
//│   }
//│   fun f$1 = (x, y, z,) => {}
//│ }
//│ 

fun f(y) =
  let g(x) = x + y + 1
  class Foo(x) {
    fun h = g(x)
  }
//│ |#fun| |f|(|y|)| |#=|→|#let| |g|(|x|)| |#=| |x| |+| |y| |+| |1|↵|#class| |Foo|(|x|)| |{|→|#fun| |h| |#=| |g|(|x|)|←|↵|}|←|
//│ Parsed: {fun f = (y,) => {let g = (x,) => +(+(x, y,), 1,); class Foo(x,) {fun h = g(x,)}}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, N, Nil, L(Lam(Tup((N, Var("y"))), Blk(NuFunDef(Some(false), g, N, Nil, L(Lam(Tup((N, Var("x"))), App(Var("+"), Tup((N, App(Var("+"), Tup((N, Var("x")), (N, Var("y"))))), (N, IntLit(1))))))), NuTypeDef(Cls, TypeName("Foo"), Ls(), S(Tup((N, Var("x")))), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, h, N, Nil, L(App(Var("g"), Tup((N, Var("x")))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1([x, y,]) {fun h = () => g$2((this).x, y,)}
//│   let g$2 = (x, y,) => +(+(x, y,), 1,)
//│   fun f$1 = (y,) => {}
//│ }
//│ 
  Foo(1).h
//│ | |Foo|(|1|)|.h|
//│ Parsed: {(Foo(1,)).h}
//│ Parsed:
//│ TypingUnit(Sel(App(Var("Foo"), Tup((N, IntLit(1)))), h))
//│ Lifted:
//│ TypingUnit {Code(List((Foo(1,)).h))}
//│ 
  Foo(x).h
//│ | |Foo|(|x|)|.h|
//│ Parsed: {(Foo(x,)).h}
//│ Parsed:
//│ TypingUnit(Sel(App(Var("Foo"), Tup((N, Var("x")))), h))
//│ Lifted:
//│ TypingUnit {Code(List((Foo(x,)).h))}
//│ 

fun f(x) =
  let g(x) = 
    let h(x) = x + 2
    Foo(h(x), x).bar
  class Foo(x, y) {
    fun bar = g(x)+y
  }
  Foo(x, x).bar
//│ |#fun| |f|(|x|)| |#=|→|#let| |g|(|x|)| |#=| |→|#let| |h|(|x|)| |#=| |x| |+| |2|↵|Foo|(|h|(|x|)|,| |x|)|.bar|←|↵|#class| |Foo|(|x|,| |y|)| |{|→|#fun| |bar| |#=| |g|(|x|)|+|y|←|↵|}|↵|Foo|(|x|,| |x|)|.bar|←|
//│ Parsed: {fun f = (x,) => {let g = (x,) => {let h = (x,) => +(x, 2,); (Foo(h(x,), x,)).bar}; class Foo(x, y,) {fun bar = +(g(x,), y,)}; (Foo(x, x,)).bar}}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, N, Nil, L(Lam(Tup((N, Var("x"))), Blk(NuFunDef(Some(false), g, N, Nil, L(Lam(Tup((N, Var("x"))), Blk(NuFunDef(Some(false), h, N, Nil, L(Lam(Tup((N, Var("x"))), App(Var("+"), Tup((N, Var("x")), (N, IntLit(2))))))), Sel(App(Var("Foo"), Tup((N, App(Var("h"), Tup((N, Var("x"))))), (N, Var("x")))), bar))))), NuTypeDef(Cls, TypeName("Foo"), Ls(), S(Tup((N, Var("x")), (N, Var("y")))), N, N, Ls(), N, N, TypingUnit(NuFunDef(None, bar, N, Nil, L(App(Var("+"), Tup((N, App(Var("g"), Tup((N, Var("x"))))), (N, Var("y")))))))), Sel(App(Var("Foo"), Tup((N, Var("x")), (N, Var("x")))), bar))))))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1([x, y,]) {fun bar = () => +(g$2((this).x,), (this).y,)}
//│   let h$3 = (x,) => +(x, 2,)
//│   let g$2 = (x,) => {(Foo$1(h$3(x,), x,)).bar}
//│   fun f$1 = (x,) => {(Foo$1(x, x,)).bar}
//│ }
//│ 

class Foo(x, y) extends Bar(y, x), Baz(x + y)
//│ |#class| |Foo|(|x|,| |y|)| |#extends| |Bar|(|y|,| |x|)|,| |Baz|(|x| |+| |y|)|
//│ Parsed: {class Foo(x, y,): Bar(y, x,), Baz(+(x, y,),) {}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("Foo"), Ls(), S(Tup((N, Var("x")), (N, Var("y")))), N, N, Ls(App(Var("Bar"), Tup((N, Var("y")), (N, Var("x")))), App(Var("Baz"), Tup((N, App(Var("+"), Tup((N, Var("x")), (N, Var("y")))))))), N, N, TypingUnit()))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1([x, y,]): Bar((this).y, (this).x,), Baz(+((this).x, (this).y,),) {}
//│ }
//│ 

fun foo<T, U>(x: T): string = 
  class A(y) extends B<T>, C(y: U) {
    fun bar = this
  }
  "rua"
//│ |#fun| |foo|‹|T|,| |U|›|(|x|#:| |T|)|#:| |string| |#=| |→|#class| |A|(|y|)| |#extends| |B|‹|T|›|,| |C|(|y|#:| |U|)| |{|→|#fun| |bar| |#=| |this|←|↵|}|↵|"rua"|←|
//│ Parsed: {fun foo = (x: T,) => {class A(y,): B‹T›, C(y: U,) {fun bar = this}; "rua"} : string}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, foo, N, TypeName("T") :: TypeName("U") :: Nil, L(Lam(Tup((S(Var("x")), Var("T"))), Asc(Blk(NuTypeDef(Cls, TypeName("A"), Ls(), S(Tup((N, Var("y")))), N, N, Ls(TyApp(Var("B"), List(TypeName(T))), App(Var("C"), Tup((S(Var("y")), Var("U"))))), N, N, TypingUnit(NuFunDef(None, bar, N, Nil, L(Var("this"))))), StrLit(rua)), TypeName(string))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1[T,U]([y,]): B‹T›, C(y: U,) {fun bar = () => this}
//│   fun foo$1[T, U] = (x: T,) => {"rua"} : string
//│ }
//│ 

class A<T>{
  class B{
    fun f = x => y => x
    fun g: T => B => T
  }
}
//│ |#class| |A|‹|T|›|{|→|#class| |B|{|→|#fun| |f| |#=| |x| |#=>| |y| |#=>| |x|↵|#fun| |g|#:| |T| |#=>| |B| |#=>| |T|←|↵|}|←|↵|}|
//│ Parsed: {class A‹T› {class B {fun f = (x,) => (y,) => x; fun g: T -> B -> T}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("A"), Ls(N -> TypeName("T")), N, N, N, Ls(), N, N, TypingUnit(NuTypeDef(Cls, TypeName("B"), Ls(), N, N, N, Ls(), N, N, TypingUnit(NuFunDef(None, f, N, Nil, L(Lam(Tup((N, Var("x"))), Lam(Tup((N, Var("y"))), Var("x"))))), NuFunDef(None, g, N, Nil, R(PolyType(Ls(), Function(Tuple(N -> Fld(N, TypeName("T"))), Function(Tuple(N -> Fld(N, TypeName("B"))), TypeName("T")))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1_B$2_Lambda1$1$3([par$A$1_B$2, x,]) {fun apply = (y,) => (this).x}
//│   class A$1_B$2[T]([par$A$1,]) {
//│     fun f = (x,) => {new A$1_B$2_Lambda1$1$3([this, x,]) {}}
//│     fun g = T -> A$1_B$2 -> T
//│   }
//│   class A$1[T]([]) {}
//│ }
//│ 

class Foo<T>{
  class RectangleBox: Box<T> & { breadth: T }
  class StackedRectangleBoxes<N> : RectangleBox<T> & { size: N }
  class Bar: {any: RectangleBox => StackedRectangleBoxes}
}
//│ |#class| |Foo|‹|T|›|{|→|#class| |RectangleBox|#:| |Box|‹|T|›| |&| |{| |breadth|#:| |T| |}|↵|#class| |StackedRectangleBoxes|‹|N|›| |#:| |RectangleBox|‹|T|›| |&| |{| |size|#:| |N| |}|↵|#class| |Bar|#:| |{|any|#:| |RectangleBox| |#=>| |StackedRectangleBoxes|}|←|↵|}|
//│ Parsed: {class Foo‹T› {class RectangleBox: Box[T] & {breadth: T} {}; class StackedRectangleBoxes‹N›: RectangleBox[T] & {size: N} {}; class Bar: {any: RectangleBox -> StackedRectangleBoxes} {}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("Foo"), Ls(N -> TypeName("T")), N, N, N, Ls(), N, N, TypingUnit(NuTypeDef(Cls, TypeName("RectangleBox"), Ls(), N, N, S(Inter(AppliedType(TypeName("Box"), TypeName("T") :: Nil), Record(breadth: Fld(N, TypeName("T"))))), Ls(), N, N, TypingUnit()), NuTypeDef(Cls, TypeName("StackedRectangleBoxes"), Ls(N -> TypeName("N")), N, N, S(Inter(AppliedType(TypeName("RectangleBox"), TypeName("T") :: Nil), Record(size: Fld(N, TypeName("N"))))), Ls(), N, N, TypingUnit()), NuTypeDef(Cls, TypeName("Bar"), Ls(), N, N, S(Record(any: Fld(N, Function(Tuple(N -> Fld(N, TypeName("RectangleBox"))), TypeName("StackedRectangleBoxes"))))), Ls(), N, N, TypingUnit()))))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1_RectangleBox$2([par$Foo$1,]) {}
//│   class Foo$1_StackedRectangleBoxes$3[N]([par$Foo$1,]) {}
//│   class Foo$1_Bar$4([par$Foo$1,]) {}
//│   class Foo$1[T]([]) {}
//│ }
//│ 

class Func<T, U> {
  fun apply: T => U
}
class Lambda<T, U> : Func<T, U> {}
fun ctx(a,b) =
  fun foo(f: Func, x) = 
    f.apply(x)
  foo(new Lambda{
    fun apply(x) = a+x
  }, b)
//│ |#class| |Func|‹|T|,| |U|›| |{|→|#fun| |apply|#:| |T| |#=>| |U|←|↵|}|↵|#class| |Lambda|‹|T|,| |U|›| |#:| |Func|‹|T|,| |U|›| |{||}|↵|#fun| |ctx|(|a|,|b|)| |#=|→|#fun| |foo|(|f|#:| |Func|,| |x|)| |#=| |→|f|.apply|(|x|)|←|↵|foo|(|#new| |Lambda|{|→|#fun| |apply|(|x|)| |#=| |a|+|x|←|↵|}|,| |b|)|←|
//│ Parsed: {class Func‹T, U› {fun apply: T -> U}; class Lambda‹T, U›: Func[T, U] {}; fun ctx = (a, b,) => {fun foo = (f: Func, x,) => {(f).apply(x,)}; foo(new Lambda { ‹fun apply = (x,) => +(a, x,)› }, b,)}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("Func"), Ls(N -> TypeName("T"), N -> TypeName("U")), N, N, N, Ls(), N, N, TypingUnit(NuFunDef(None, apply, N, Nil, R(PolyType(Ls(), Function(Tuple(N -> Fld(N, TypeName("T"))), TypeName("U"))))))), NuTypeDef(Cls, TypeName("Lambda"), Ls(N -> TypeName("T"), N -> TypeName("U")), N, N, S(AppliedType(TypeName("Func"), TypeName("T") :: TypeName("U") :: Nil)), Ls(), N, N, TypingUnit()), NuFunDef(None, ctx, N, Nil, L(Lam(Tup((N, Var("a")), (N, Var("b"))), Blk(NuFunDef(None, foo, N, Nil, L(Lam(Tup((S(Var("f")), Var("Func")), (N, Var("x"))), Blk(App(Sel(Var("f"), apply), Tup((N, Var("x")))))))), App(Var("foo"), Tup((N, Rft(NuNew(Var("Lambda")), TypingUnit(NuFunDef(None, apply, N, Nil, L(Lam(Tup((N, Var("x"))), App(Var("+"), Tup((N, Var("a")), (N, Var("x")))))))))), (N, Var("b")))))))))
//│ Lifted:
//│ TypingUnit {
//│   class Func$1[T,U]([]) {fun apply = T -> U}
//│   class Lambda$2[T,U]([]) {}
//│   fun foo$2 = (f: Func$1, x,) => {(f).apply(x,)}
//│   fun ctx$1 = (a, b,) => {foo$2(new Lambda$2([]) {}, b,)}
//│ }
//│ 

fun f(T) = 
  new T()
f(MyClass)
//│ |#fun| |f|(|T|)| |#=| |→|#new| |T|(||)|←|↵|f|(|MyClass|)|
//│ Parsed: {fun f = (T,) => {(new T)()}; f(MyClass,)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, f, N, Nil, L(Lam(Tup((N, Var("T"))), Blk(App(NuNew(Var("T")), Tup()))))), App(Var("f"), Tup((N, Var("MyClass")))))
//│ Lifted:
//│ Lifting failed: mlscript.codegen.CodeGenError: Cannot find type T. Class values are not supported in lifter. 
//│ 

class A {
  fun foo = 
    fun bar = foo()
    bar()
}
//│ |#class| |A| |{|→|#fun| |foo| |#=| |→|#fun| |bar| |#=| |foo|(||)|↵|bar|(||)|←|←|↵|}|
//│ Parsed: {class A {fun foo = {fun bar = foo(); bar()}}}
//│ Parsed:
//│ TypingUnit(NuTypeDef(Cls, TypeName("A"), Ls(), N, N, N, Ls(), N, N, TypingUnit(NuFunDef(None, foo, N, Nil, L(Blk(NuFunDef(None, bar, N, Nil, L(App(Var("foo"), Tup()))), App(Var("bar"), Tup())))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1([]) {fun foo = () => {bar$1(this,)}}
//│   fun bar$1 = (this,) => (this).foo()
//│ }
//│ 
