:NewDefs

:AllowRuntimeErrors
fun foo() =
  let local(x) =
    class Foo {
      fun bar = x + foo()
    }
    (new Foo()).bar
  local(1)
foo()
//│ Parsed:
//│ TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List()),Blk(List(NuFunDef(Some(false),Var(local),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(x))))),Blk(List(NuTypeDef(Cls,TypeName(Foo),List(),None,None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(bar),None,List(),Left(App(Var(+),Tup(List((None,Fld(_,Var(x))), (None,Fld(_,App(Var(foo),Tup(List())))))))))))), Sel(Bra(false,App(NuNew(Var(Foo)),Tup(List()))),Var(bar))))))), App(Var(local),Tup(List((None,Fld(_,IntLit(1))))))))))), App(Var(foo),Tup(List()))))
//│ Lifted:
//│ TypingUnit {
//│   class Foo$1([x,]) {fun bar = () => +((this).x, foo$1(),)}
//│   let local$2 = (x,) => {('(' new Foo$1([x,]) {} ')').bar}
//│   fun foo$1 = () => {local$2(1,)}
//│   Code(List(foo$1()))
//│ }
//│ fun foo: () -> Int
//│ Int
//│ res
//│ Runtime error:
//│   RangeError: Maximum call stack size exceeded

fun foo(f) = 
  f(1)
foo(x => x+1)
//│ Parsed:
//│ TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(f))))),Blk(List(App(Var(f),Tup(List((None,Fld(_,IntLit(1))))))))))), App(Var(foo),Tup(List((None,Fld(_,Lam(Tup(List((None,Fld(_,Var(x))))),App(Var(+),Tup(List((None,Fld(_,Var(x))), (None,Fld(_,IntLit(1))))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$2$1([]) {fun apply = (x,) => +(x, 1,)}
//│   fun foo$1 = (f,) => {f(1,)}
//│   Code(List(foo$1({new Lambda1$2$1([]) {}},)))
//│ }
//│ fun foo: forall 'a. (1 -> 'a) -> 'a
//│ Int
//│ res
//│     = 2

fun foo(x) = 
  let bar(f) = 
    f(x)
  bar(y => y+x)
foo(1)
//│ Parsed:
//│ TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(x))))),Blk(List(NuFunDef(Some(false),Var(bar),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(f))))),Blk(List(App(Var(f),Tup(List((None,Fld(_,Var(x))))))))))), App(Var(bar),Tup(List((None,Fld(_,Lam(Tup(List((None,Fld(_,Var(y))))),App(Var(+),Tup(List((None,Fld(_,Var(y))), (None,Fld(_,Var(x))))))))))))))))), App(Var(foo),Tup(List((None,Fld(_,IntLit(1))))))))
//│ Lifted:
//│ TypingUnit {
//│   class Lambda1$3$1([x,]) {fun apply = (y,) => +(y, (this).x,)}
//│   let bar$2 = (f, x,) => {f(x,)}
//│   fun foo$1 = (x,) => {bar$2({new Lambda1$3$1([x,]) {}}, x,)}
//│   Code(List(foo$1(1,)))
//│ }
//│ fun foo: Int -> Int
//│ Int
//│ res
//│     = 2

fun foo(f) = 
    f(1)
class A(y: Int){
  fun bar(z) = y+z
}
fun app(a) = 
  foo(z => a.bar(z))
app(new A(1))
//│ Parsed:
//│ TypingUnit(List(NuFunDef(None,Var(foo),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(f))))),Blk(List(App(Var(f),Tup(List((None,Fld(_,IntLit(1))))))))))), NuTypeDef(Cls,TypeName(A),List(),Some(Tup(List((Some(Var(y)),Fld(_,Var(Int)))))),None,None,List(),None,None,TypingUnit(List(NuFunDef(None,Var(bar),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(z))))),App(Var(+),Tup(List((None,Fld(_,Var(y))), (None,Fld(_,Var(z)))))))))))), NuFunDef(None,Var(app),None,List(),Left(Lam(Tup(List((None,Fld(_,Var(a))))),Blk(List(App(Var(foo),Tup(List((None,Fld(_,Lam(Tup(List((None,Fld(_,Var(z))))),App(Sel(Var(a),Var(bar)),Tup(List((None,Fld(_,Var(z))))))))))))))))), App(Var(app),Tup(List((None,Fld(_,App(NuNew(Var(A)),Tup(List((None,Fld(_,IntLit(1)))))))))))))
//│ Lifted:
//│ TypingUnit {
//│   class A$1([y: Int,]) {fun bar = (z,) => +((this).y, z,)}
//│   class Lambda1$3$2([a,]) {fun apply = (z,) => ((this).a).bar(z,)}
//│   fun foo$2 = (f,) => {f(1,)}
//│   fun app$1 = (a,) => {foo$2({new Lambda1$3$2([a,]) {}},)}
//│   Code(List(app$1(new A$1([1,]) {},)))
//│ }
//│ fun foo: forall 'a. (1 -> 'a) -> 'a
//│ class A(y: Int) {
//│   fun bar: Int -> Int
//│ }
//│ fun app: forall 'b. {bar: 1 -> 'b} -> 'b
//│ Int
//│ res
//│     = 2
